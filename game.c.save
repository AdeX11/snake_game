#include <ncurses.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "snake.h"
#include "food.h"
#include "game_window.h"
#include "key.h"
#include "game.h"
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include "obstacle.h"
void generate_points(int *food_x, int *food_y, int width, int height, int x_offset, int y_offset){
    *food_x = rand() % width + x_offset;
    *food_y = rand() % height + y_offset;
}
void game(){
    enum State state = INIT; // Set the initial state
    static int x_max, y_max; //Max screen size variables
    static int x_offset, y_offset; // distance between the top left corner of your screen and the start of the board
    // top of board ^
    gamewindow_t *window; // Name of the board
    static int windowSize = 0;
    Snake *snake; // The snake
    Food *foods,*new_food; // List of foods (Not an array)

    static int points = 0;
    static int foodEaten = 0;
    int array[6];
    const int height = 35; 
    const int width = 70;
    char ch, currentDirection = RIGHT;
    char cantGoInDirection = LEFT;
    char vertEdge = NOCHAR;
    char horiEdge = NOCHAR;

    struct timespec timeret;
    timeret.tv_sec = 0;
    timeret.tv_nsec = 999999999/4;
    static int speed = 4;
   // THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //obstacles
    srand(time(NULL));
    int obstacleCt = (rand() % (7 - 3 + 1)) + 3; //between 3 and 7
    static int obsSize, obs_x, obs_y;
    enum Dir obsDirection;
    Obs *obstacles, *newObs, *newSub;
    static int lives = 3;

    while(state != EXIT){
        switch(state){
        case INIT:
            initscr();
            start_color();
            nodelay(stdscr, TRUE); //Dont wait for char
            noecho(); // Don't echo input chars
            getmaxyx(stdscr, y_max, x_max);
            keypad(stdscr, TRUE); // making keys work
            curs_set(0); // hide cursor
            timeout(100);

            // Setting height and width of the board
            x_offset = (x_max / 2) - (width / 2);
            y_offset = (y_max / 2) - (height / 2);
            
            //Init board
            window = init_GameWindow(x_offset, y_offset, width, height);
            draw_Gamewindow(window);

            // Init snake
            snake = init_snake(x_offset + (width / 2), y_offset + (height / 2));
            
            // Init foods
            int food_x, food_y, i;
            enum Type type, eatenType;
            srand(time(NULL));
            //Generate 10 foods
            generate_points(&food_x, &food_y, width, height, x_offset, y_offset);
            type = (rand() > RAND_MAX/2) ? Increase : Decrease; // Randomly deciding type of food
            foods = create_food(food_x, food_y, type);
            for(i = 1; i < 20; i++){
                generate_points(&food_x, &food_y, width, height, x_offset, y_offset);
                while (food_exists(foods,food_x, food_y))
                    generate_points(&food_x, &food_y, width, height, x_offset, y_offset);
                type = (rand() > RAND_MAX/2) ? Increase : Decrease;
                new_food = create_food(food_x, food_y, type);
                add_new_food(foods, new_food);
            }
           // THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            int j;
            // generate obstacles starting away from edge
            for(i = 1; i < obstacleCt; i++) { 
                // generate first obs
                generate_points(&obs_x, &obs_y, width - 7, height - 7, x_offset + 7, y_offset + 7);
                obsDirection = (rand() > RAND_MAX/2) ? vertical : horizontal; //random direction
                newObs = create_obs(obs_x, obs_y);
                // check if obstiicals exist yet
                if (i == 1) {
                    obstacles = newObs;
                }
                else {
                    add_new_obs(obstacles, newObs);
                }
                // determine random size in window
                if (obsDirection == vertical) obsSize = (rand() % (height - 1)) + 1; //at least 1 or 2 less than the height
                else obsSize = (rand() % (width - 1)) + 1; //at least 1 or 2 less than the width

                // generate rest of obstical
                for (j = 1; j <= obsSize; j++) {
                    if (obsDirection == vertical && (newObs->y + j) < height) {
                        newSub = create_obs(newObs->x, newObs->y + j);
                        add_new_obs(obstacles, newSub);
                    }
                    else if (obsDirection == horizontal && (newObs->x + j) < width) {
                        newSub = create_obs(newObs->x + j, newObs->y);
                        add_new_obs(obstacles, newSub);
                    }
                }
            }
            state = ALIVE;
            break;

        case ALIVE:
            ch = get_char();
            
            // check for quit or pause
            if (ch == 'Q' || ch == 'q') {
                state = DEAD;lives--;
            }
            if (ch == 'p' || ch == 'P') {
                state = PAUSE;
            }

            //check for window size change
            if (ch == '+' && windowSize < 25) {
                windowSize += 5;
                x_max += 5;
                y_max += 5;
                // increase both sides by 5 to expand
                window = changeGameWindow(x_offset, y_offset, width + windowSize, height + windowSize, window);
                // change coordinates of board elements/food respectively
                generate_points(&food_x, &food_y, width + windowSize, height + windowSize, x_offset, y_offset);
                type = (rand() > RAND_MAX/2) ? Increase : Decrease;
                foods = create_food(food_x, food_y, type);
                for(i = 1; i < 20; i++) {
                    generate_points(&food_x, &food_y, width + windowSize, height + windowSize, x_offset, y_offset);
                    while (food_exists(foods,food_x, food_y))
                        generate_points(&food_x, &food_y, width + windowSize, height + windowSize, x_offset, y_offset);
                    type = (rand() > RAND_MAX/2) ? Increase : Decrease;
                    new_food = create_food(food_x, food_y, type);
                    add_new_food(foods, new_food);
                }
            }
            if (ch == '-' && windowSize > -25) {
                windowSize -= 5;
                x_max -= 5;
                y_max -= 5;
                // decrease both sides by 5 to shrink
                window = changeGameWindow(x_offset, y_offset, width + windowSize, height + windowSize, window);
                // change coordinates of board elements/food respectively
                generate_points(&food_x, &food_y, width + windowSize, height + windowSize, x_offset, y_offset);
                type = (rand() > RAND_MAX/2) ? Increase : Decrease;
                foods = create_food(food_x, food_y, type);
                for(i = 1; i < 20; i++) {
                    generate_points(&food_x, &food_y, width + windowSize, height + windowSize, x_offset, y_offset);
                    while (food_exists(foods,food_x, food_y))
                        generate_points(&food_x, &food_y, width + windowSize, height + windowSize, x_offset, y_offset);
                    type = (rand() > RAND_MAX/2) ? Increase : Decrease;
                    new_food = create_food(food_x, food_y, type);
                    add_new_food(foods, new_food);
                }
            }

            //check for direction change/movement keys
            else if(ch >= LEFT && ch <= DOWN) { 
                // check if snake at edges of board
                // if (snake->x == x_max) horiEdge = RIGHT;
                // if (snake->x == (x_max - width)) horiEdge = LEFT;
                // if (snake->y == y_max) vertEdge = UP;
                // if (snake->y == (y_max - height)) vertEdge = DOWN;

                // change direction if can
                if (ch != cantGoInDirection && ch != horiEdge && ch != vertEdge) {
                    // set forward direction and set as current direction
                    if (ch == LEFT || ch == UP) {
                        //cant go in opposite direction
                        cantGoInDirection = ch + 1;
                    }
                    else {
                        cantGoInDirection = ch - 1;
                    }
                    // snake = move_snake(snake, ch);
                    //change current direction
                    currentDirection = ch;
                }
            }
                // horiEdge = NOCHAR;
                // vertEdge = NOCHAR;

            // move snake
            snake = move_snake(snake, currentDirection,window);
            
	    // check for obstacles
            if (obs_exists(obstacles, snake->x, snake->y)) {
                // reverse snake
                snake = reverseSnake(snake);

                // go in opposite direction
                if (currentDirection == LEFT || currentDirection == UP) {
                    currentDirection += 1;
                }
                else {
                    currentDirection -= 1;
                }
                snake = move_snake(snake, currentDirection, window);
            }            



            // check for food
            if (food_exists(foods, snake->x, snake->y)) {
                // collect food data
                foodEaten++;
                eatenType = food_type(foods, snake->x, snake->y);

                // remove food and replace
                foods = remove_eaten_food(foods, snake->x, snake->y);
                generate_points(&food_x, &food_y, width + windowSize, height + windowSize, x_offset, y_offset);
                type = (rand() > RAND_MAX/2) ? Increase : Decrease;
                new_food = create_food(food_x, food_y, type);
                add_new_food(foods, new_food);

                //add to points and modify snake size
                if (eatenType == 'O' || eatenType == '+') {
                    points += 20;
                    grow(snake, currentDirection);
                }
                else {
                    points -= 10;
		    if(snake->next == NULL)
                    {
                      snake = NULL;state=DEAD;lives--;
                    }
		    else  remove_tail(snake);
                }

                //modify speed
                if ((foodEaten % 10) == 0) {
                    speed = speed * 1.5;
                    timeret.tv_nsec = 999999999/speed;
                }
            }
            // Draw everything on the screen
            clear();
            mvprintw(10,20, "Your Score: %d", points);
            mvprintw(15,20, "Food eaten: %d", foodEaten);
            mvprintw(20,20, "Key entered: %c", ch);
            mvprintw(30, 20, "Window size: %d", windowSize);
            // mvprintw(15,20, "you ate: %d", eatenType);
            draw_Gamewindow(window);draw_obs(obstacles);
            draw_snake(snake);
            draw_food(foods);
            break;
        case PAUSE:
	    mvprintw(20,95, "'P' to play, 'Q' to quit\n'F' to save the file");
            ch = get_char();
            if (ch == 'Q') {
                state = DEAD;lives--;
            }
            if (ch == 'p' || ch == 'P') {
                state = ALIVE;
            }
	    if (ch == 'f' || ch == 'F')
	    {
		char*file = "saves";
	        char*str = (char *)malloc(100*sizeof(char));

		mvprintw(20,95, "What File Name would you like to save the file: ?");
		scanf("%s",str);strcat(file,str);
		FILE *fp;
		fp = fopen(str,"w");
		fwrite(snake,sizeof(snake),1,fp);fwrite(foods,sizeof(foods),1,fp);
		fwrite(obstacles,sizeof(obstacles),1,fp);fwrite(window,sizeof(window),1,fp);
		fclose(fp);
	    }
            
            break;
        case DEAD:
            clear();
            mvprintw(20,95, "GAME OVER");
            mvprintw(25,95, "Your Score: %d", points);
            mvprintw(27,95, "Lives left: %d", lives);

            //check lives
            if (lives > 0) {
                ch = get_char();
                if (ch == 'Q' || 'q') {
                    state = EXIT;
                }
                if (ch == 'p' || ch == 'P') {
                    state = INIT;
                }
                mvprintw(30,95, "'P' to play again, 'Q' to quit");
            }
            else {
                ch = get_char();
                if (ch == 'Q'|| ch == 'q' ) {
                    state = EXIT;
                }
                mvprintw(30,95, "Press 'Q' to quit");
            }
            break;
        }
        refresh();
        nanosleep(&timeret, NULL);
    }
    //end
    undraw_Gamewindow(window);
    endwin();
    FILE *fp;
    int check;
    char * line = NULL;
    size_t len = 0;
    ssize_t read;
    const size_t line_size = 300;
    
    int i=0;
    if(true)
    {
    
      fp = fopen("./saves/save_best_5.game", "r");
      if((read = getline(&line, &len, fp)) != -1)
      {
      
        char* token = strtok(line, " ");
        while (token != NULL) 
        {
          array[i++] = atoi(token);
          token = strtok(NULL, " ");
        }
        array[i++] = points;
        int j; int k,tmp;
        for(j=0; j<i; ++j)
        {
          for(k=j+1; k<i; ++k)
          {
              if(array[j] <array[k])
              {
                tmp = array[j];
                array[j] = array[k];
                array[k] = tmp;
              }
          }
            
        }
      }     
      int l;
      fclose(fp);
      fp = fopen("./saves/save_best_5.game", "w");
      if(fp != NULL)
      {
        for(l = 0; l <i&& l<5; l++)
        {
          fprintf(fp,"%d ", array[l]);
        }
        fclose(fp);
      }
    } 
   
    
}
